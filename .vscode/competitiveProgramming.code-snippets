{
    "Template": {
        "prefix": "template",
        "body": [
            "#include <bits/stdc++.h>",
            "#include <atcoder/all>",
            "#define fr first",
            "#define sc second",
            "#define rep(i, n) for (int i = 0; i < (n); ++i)",
            "#define rep1(i, n) for (int i = 1; i <= (n); ++i)",
            "#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)",
            "#define rrep1(i, n) for (int i = (n); i >= 1; --i)",
            "#define srep(i, s, t) for (int i = s; i < t; ++i)",
            "#define rng(a) a.begin(), a.end()",
            "#define rrng(a) a.rbegin(), a.rend()",
            "#define isin(x, l, r) ((l) <= (x) && (x) < (r))",
            "#define pb push_back",
            "#define eb emplace_back",
            "#define sz(x) (int)(x).size()",
            "#define pcnt __builtin_popcountll",
            "#define uni(x) x.erase(unique(rng(x)), x.end())",
            "#define snuke srand((unsigned)clock() + (unsigned)time(NULL));",
            "#define show(x) cout << #x << \" = \" << x << endl;",
            "#define PQ(T) priority_queue<T, v(T), greater<T>>",
            "#define bn(x) ((1 << x) - 1)",
            "#define dup(x, y) (((x) + (y)-1) / (y))",
            "#define newline puts(\"\")",
            "#define v(T) vector<T>",
            "#define vv(T) v(v(T))",
            "using namespace std;",
            "using namespace atcoder;",
            "using ll = long long;",
            "using uint = unsigned;",
            "using ull = unsigned long long;",
            "using P = pair<int, int>;",
            "using LP = pair<ll, ll>;",
            "using vi = vector<int>;",
            "using vvi = vector<vi>;",
            "using vl = vector<ll>;",
            "using vp = vector<P>;",
            "using vlp = vector<LP>;",
            "inline int getInt()",
            "{",
            "    int x;",
            "    scanf(\"%d\", &x);",
            "    return x;",
            "}",
            "template <class T>",
            "bool chmax(T &a, const T &b)",
            "{",
            "    if (a < b)",
            "    {",
            "        a = b;",
            "        return true;",
            "    }",
            "    return false;",
            "}",
            "template <class T>",
            "bool chmin(T &a, const T &b)",
            "{",
            "    if (a > b)",
            "    {",
            "        a = b;",
            "        return true;",
            "    }",
            "    return false;",
            "}",
            "",
            "void solve()",
            "{",
            "    ",
            "}",
            "",
            "int main()",
            "{",
            "    cin.tie(nullptr);",
            "    ios::sync_with_stdio(false);",
            "    cout << fixed << setprecision(15);",
            "    solve();",
            "    return 0;",
            "}",
        ]
    },
    "BiCoef": {
        "prefix": "BiCoef",
        "body": [
            "// 素数 p で割ったあまりに関する構造体 (特に p = 1000000007 とすることが多い)",
            "template<int MOD> struct Fp {",
            "    long long val;",
            "    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {",
            "        if (val < 0) v += MOD;",
            "    }",
            "    constexpr int getmod() { return MOD; }",
            "    constexpr Fp operator - () const noexcept {",
            "        return val ? MOD - val : 0;",
            "    }",
            "    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }",
            "    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }",
            "    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }",
            "    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }",
            "    constexpr Fp& operator += (const Fp& r) noexcept {",
            "        val += r.val;",
            "        if (val >= MOD) val -= MOD;",
            "        return *this;",
            "    }",
            "    constexpr Fp& operator -= (const Fp& r) noexcept {",
            "        val -= r.val;",
            "        if (val < 0) val += MOD;",
            "        return *this;",
            "    }",
            "    constexpr Fp& operator *= (const Fp& r) noexcept {",
            "        val = val * r.val % MOD;",
            "        return *this;",
            "    }",
            "    constexpr Fp& operator /= (const Fp& r) noexcept {",
            "        long long a = r.val, b = MOD, u = 1, v = 0;",
            "        while (b) {",
            "            long long t = a / b;",
            "            a -= t * b; swap(a, b);",
            "            u -= t * v; swap(u, v);",
            "        }",
            "        val = val * u % MOD;",
            "        if (val < 0) val += MOD;",
            "        return *this;",
            "    }",
            "    constexpr bool operator == (const Fp& r) const noexcept {",
            "        return this->val == r.val;",
            "    }",
            "    constexpr bool operator != (const Fp& r) const noexcept {",
            "        return this->val != r.val;",
            "    }",
            "    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {",
            "        return os << x.val;",
            "    }",
            "    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {",
            "        return is >> x.val;",
            "    }",
            "    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {",
            "        if (n == 0) return 1;",
            "        auto t = modpow(a, n / 2);",
            "        t = t * t;",
            "        if (n & 1) t = t * a;",
            "        return t;",
            "    }",
            "};",
            "",
            "// 二項係数ライブラリ",
            "template<class T> struct BiCoef {",
            "    vector<T> fact_, inv_, finv_;",
            "    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {",
            "        int MOD = fact_[0].getmod();",
            "        for(int i = 2; i < n; i++){",
            "            fact_[i] = fact_[i-1] * i;",
            "            inv_[i] = -inv_[MOD%i] * (MOD/i);",
            "            finv_[i] = finv_[i-1] * inv_[i];",
            "        }",
            "    }",
            "    constexpr T com(int n, int k) const noexcept {",
            "        if (n < k || n < 0 || k < 0) return 0;",
            "        return fact_[n] * finv_[k] * finv_[n-k];",
            "    }",
            "    constexpr T fact(int n) const noexcept {",
            "        if (n < 0) return 0;",
            "        return fact_[n];",
            "    }",
            "    constexpr T inv(int n) const noexcept {",
            "        if (n < 0) return 0;",
            "        return inv_[n];",
            "    }",
            "    constexpr T finv(int n) const noexcept {",
            "        if (n < 0) return 0;",
            "        return finv_[n];",
            "    }",
            "};",
        ],
        "description": ""
    },
    "LCA": {
        "prefix": "LCA",
        "body": [
            "/**",
            " * Lowest Common Ancestor",
            " */",
            "class LCA",
            "{",
            "private:",
            "    int root;",
            "    int k;                  // n<=2^kとなる最小のk",
            "    vector<vector<int>> dp; // dp[i][j]:=要素jの2^i上の要素",
            "    vector<int> depth;      // depth[i]:=rootに対する頂点iの深さ",
            "",
            "public:",
            "    LCA(const vector<vector<int>> &_G, const int _root = 0)",
            "    {",
            "        int n = _G.size();",
            "        root = _root;",
            "        k = 1;",
            "        int nibeki = 2;",
            "        while (nibeki < n)",
            "        {",
            "            nibeki <<= 1;",
            "            k++;",
            "        }",
            "        // 頂点iの親ノードを初期化",
            "        dp = vector<vector<int>>(k + 1, vector<int>(n, -1));",
            "        depth.resize(n);",
            "        function<void(int, int)> _dfs = [&](int v, int p) {",
            "            dp[0][v] = p;",
            "            for (auto nv : _G[v])",
            "            {",
            "                if (nv == p)",
            "                    continue;",
            "                depth[nv] = depth[v] + 1;",
            "                _dfs(nv, v);",
            "            }",
            "        };",
            "        _dfs(root, -1);",
            "        // ダブリング",
            "        for (int i = 0; i < k; i++)",
            "        {",
            "            for (int j = 0; j < n; j++)",
            "            {",
            "                if (dp[i][j] == -1)",
            "                    continue;",
            "                dp[i + 1][j] = dp[i][dp[i][j]];",
            "            }",
            "        }",
            "    }",
            "",
            "    /// get LCA",
            "    int get(int u, int v)",
            "    {",
            "        if (depth[u] < depth[v])",
            "            swap(u, v); // u側を深くする",
            "        if (depth[u] != depth[v])",
            "        {",
            "            long long d = depth[u] - depth[v];",
            "            for (int i = 0; i < k; i++)",
            "                if ((d >> i) & 1)",
            "                    u = dp[i][u];",
            "        }",
            "        if (u == v)",
            "            return u;",
            "",
            "        for (int i = k; i >= 0; i--)",
            "        {",
            "            if (dp[i][u] != dp[i][v])",
            "            {",
            "                u = dp[i][u], v = dp[i][v];",
            "            }",
            "        }",
            "        return dp[0][u];",
            "    }",
            "",
            "    int get_distance(const int u, const int v)",
            "    {",
            "        int lca = get(u, v);",
            "        return depth[u] + depth[v] - 2 * depth[lca];",
            "    }",
            "};",
        ],
        "description": ""
    },
}